code = <script src="cdjs/constants.js"></script>
<script src="cdjs/util.js"></script>
<script src="cdjs/red_black_tree.js"></script>
<script src="cdjs/call_sign.js"></script>
<script src="cdjs/vector_2d.js"></script>
<script src="cdjs/vector_3d.js"></script>
<script src="cdjs/motion.js"></script>
<script src="cdjs/reduce_collision_set.js"></script>
<script src="cdjs/simulator.js"></script>
<script src="cdjs/collision.js"></script>
<script src="cdjs/collision_detector.js"></script>
<script src="cdjs/benchmark.js"></script>
<script>
console.log("running...");
var __result = benchmark();
console.log("got result: " + __result);
top.JetStream.reportResult(__result);
</script>
<tr><th>Benchmark</th><th>Average Score</th><th>Benchmark</th><th>Average Score</th><th>Benchmark</th><th>Average Score</th></tr><tr><td class="benchmark-name category">Latency</td><td class="result category" id="results-cell-geomean-Latency">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#regex-dna" target="_blank">regex-dna</a></td><td class="result" id="results-cell-regex-dna">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#gcc-loops.cpp" target="_blank">gcc-loops.cpp</a></td><td class="result" id="results-cell-gcc-loops.cpp">&mdash;</td></tr><tr><td class="benchmark-name"><a href="in-depth.html#3d-cube" target="_blank">3d-cube</a></td><td class="result" id="results-cell-3d-cube">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#splay-latency" target="_blank">splay-latency</a></td><td class="result" id="results-cell-splay-latency">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#hash-map" target="_blank">hash-map</a></td><td class="result" id="results-cell-hash-map">&mdash;</td></tr><tr><td class="benchmark-name"><a href="in-depth.html#3d-raytrace" target="_blank">3d-raytrace</a></td><td class="result" id="results-cell-3d-raytrace">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#tagcloud" target="_blank">tagcloud</a></td><td class="result" id="results-cell-tagcloud">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#mandreel" target="_blank">mandreel</a></td><td class="result" id="results-cell-mandreel">&mdash;</td></tr><tr><td class="benchmark-name"><a href="in-depth.html#base64" target="_blank">base64</a></td><td class="result" id="results-cell-base64">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#typescript" target="_blank">typescript</a></td><td class="result" id="results-cell-typescript">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#n-body.c" target="_blank">n-body.c</a></td><td class="result" id="results-cell-n-body.c">&mdash;</td></tr><tr><td class="benchmark-name"><a href="in-depth.html#cdjs" target="_blank">cdjs</a></td><td class="result" id="results-cell-cdjs">&mdash;</td><td class="benchmark-name category">Throughput</td><td class="result category" id="results-cell-geomean-Throughput">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#navier-stokes" target="_blank">navier-stokes</a></td><td class="result" id="results-cell-navier-stokes">&mdash;</td></tr><tr><td class="benchmark-name"><a href="in-depth.html#code-first-load" target="_blank">code-first-load</a></td><td class="result" id="results-cell-code-first-load">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#bigfib.cpp" target="_blank">bigfib.cpp</a></td><td class="result" id="results-cell-bigfib.cpp">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#pdfjs" target="_blank">pdfjs</a></td><td class="result" id="results-cell-pdfjs">&mdash;</td></tr><tr><td class="benchmark-name"><a href="in-depth.html#code-multi-load" target="_blank">code-multi-load</a></td><td class="result" id="results-cell-code-multi-load">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#box2d" target="_blank">box2d</a></td><td class="result" id="results-cell-box2d">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#proto-raytracer" target="_blank">proto-raytracer</a></td><td class="result" id="results-cell-proto-raytracer">&mdash;</td></tr><tr><td class="benchmark-name"><a href="in-depth.html#crypto-aes" target="_blank">crypto-aes</a></td><td class="result" id="results-cell-crypto-aes">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#container.cpp" target="_blank">container.cpp</a></td><td class="result" id="results-cell-container.cpp">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#quicksort.c" target="_blank">quicksort.c</a></td><td class="result" id="results-cell-quicksort.c">&mdash;</td></tr><tr><td class="benchmark-name"><a href="in-depth.html#crypto-md5" target="_blank">crypto-md5</a></td><td class="result" id="results-cell-crypto-md5">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#crypto" target="_blank">crypto</a></td><td class="result" id="results-cell-crypto">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#regexp-2010" target="_blank">regexp-2010</a></td><td class="result" id="results-cell-regexp-2010">&mdash;</td></tr><tr><td class="benchmark-name"><a href="in-depth.html#crypto-sha1" target="_blank">crypto-sha1</a></td><td class="result" id="results-cell-crypto-sha1">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#delta-blue" target="_blank">delta-blue</a></td><td class="result" id="results-cell-delta-blue">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#richards" target="_blank">richards</a></td><td class="result" id="results-cell-richards">&mdash;</td></tr><tr><td class="benchmark-name"><a href="in-depth.html#date-format-tofte" target="_blank">date-format-tofte</a></td><td class="result" id="results-cell-date-format-tofte">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#dry.c" target="_blank">dry.c</a></td><td class="result" id="results-cell-dry.c">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#splay" target="_blank">splay</a></td><td class="result" id="results-cell-splay">&mdash;</td></tr><tr><td class="benchmark-name"><a href="in-depth.html#date-format-xparb" target="_blank">date-format-xparb</a></td><td class="result" id="results-cell-date-format-xparb">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#earley-boyer" target="_blank">earley-boyer</a></td><td class="result" id="results-cell-earley-boyer">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#towers.c" target="_blank">towers.c</a></td><td class="result" id="results-cell-towers.c">&mdash;</td></tr><tr><td class="benchmark-name"><a href="in-depth.html#mandreel-latency" target="_blank">mandreel-latency</a></td><td class="result" id="results-cell-mandreel-latency">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#float-mm.c" target="_blank">float-mm.c</a></td><td class="result" id="results-cell-float-mm.c">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#zlib" target="_blank">zlib</a></td><td class="result" id="results-cell-zlib">&mdash;</td></tr><tr><td class="benchmark-name"><a href="in-depth.html#n-body" target="_blank">n-body</a></td><td class="result" id="results-cell-n-body">&mdash;</td><td class="benchmark-name"><a href="in-depth.html#gbemu" target="_blank">gbemu</a></td><td class="result" id="results-cell-gbemu">&mdash;</td><td class="benchmark-name geometric-mean">Geometric Mean</td><td class="result geometric-mean" id="results-cell-geomean">&mdash;</td></tr>
results-cell-geomean-Latency	&mdash;
results-cell-geomean-Throughput	&mdash;
results-cell-geomean	&mdash;
Running iteration 1
results-cell-3d-cube	<em>Runningâ€¦</em>

//top.sunSpiderCPUWarmup();
var __data = top.JetStream.getAccumulator() || {sum: 0, n: 0};
var __time_before = top.JetStream.goodTime();
// 3D Cube Rotation
// http://www.speich.net/computer/moztesting/3d.htm
// Created by Simon Speich

var Q = new Array();
var MTrans = new Array();  // transformation matrix
var MQube = new Array();  // position information of qube
var I = new Array();      // entity matrix
var Origin = new Object();
var Testing = new Object();
var LoopTimer;

var validation = {
 20: 2889.0000000000045,
 40: 2889.0000000000055,
 80: 2889.000000000005,
 160: 2889.0000000000055
};

var DisplArea = new Object();
DisplArea.Width = 300;
DisplArea.Height = 300;

function DrawLine(From, To) {
  var x1 = From.V[0];
  var x2 = To.V[0];
  var y1 = From.V[1];
  var y2 = To.V[1];
  var dx = Math.abs(x2 - x1);
  var dy = Math.abs(y2 - y1);
  var x = x1;
  var y = y1;
  var IncX1, IncY1;
  var IncX2, IncY2;  
  var Den;
  var Num;
  var NumAdd;
  var NumPix;

  if (x2 >= x1) {  IncX1 = 1; IncX2 = 1;  }
  else { IncX1 = -1; IncX2 = -1; }
  if (y2 >= y1)  {  IncY1 = 1; IncY2 = 1; }
  else { IncY1 = -1; IncY2 = -1; }
  if (dx >= dy) {
    IncX1 = 0;
    IncY2 = 0;
    Den = dx;
    Num = dx / 2;
    NumAdd = dy;
    NumPix = dx;
  }
  else {
    IncX2 = 0;
    IncY1 = 0;
    Den = dy;
    Num = dy / 2;
    NumAdd = dx;
    NumPix = dy;
  }

  NumPix = Math.round(Q.LastPx + NumPix);

  var i = Q.LastPx;
  for (; i < NumPix; i++) {
    Num += NumAdd;
    if (Num >= Den) {
      Num -= Den;
      x += IncX1;
      y += IncY1;
    }
    x += IncX2;
    y += IncY2;
  }
  Q.LastPx = NumPix;
}

function CalcCross(V0, V1) {
  var Cross = new Array();
  Cross[0] = V0[1]*V1[2] - V0[2]*V1[1];
  Cross[1] = V0[2]*V1[0] - V0[0]*V1[2];
  Cross[2] = V0[0]*V1[1] - V0[1]*V1[0];
  return Cross;
}

function CalcNormal(V0, V1, V2) {
  var A = new Array();   var B = new Array(); 
  for (var i = 0; i < 3; i++) {
    A[i] = V0[i] - V1[i];
    B[i] = V2[i] - V1[i];
  }
  A = CalcCross(A, B);
  var Length = Math.sqrt(A[0]*A[0] + A[1]*A[1] + A[2]*A[2]); 
  for (var i = 0; i < 3; i++) A[i] = A[i] / Length;
  A[3] = 1;
  return A;
}

function CreateP(X,Y,Z) {
  this.V = [X,Y,Z,1];
}

// multiplies two matrices
function MMulti(M1, M2) {
  var M = [[],[],[],[]];
  var i = 0;
  var j = 0;
  for (; i < 4; i++) {
    j = 0;
    for (; j < 4; j++) M[i][j] = M1[i][0] * M2[0][j] + M1[i][1] * M2[1][j] + M1[i][2] * M2[2][j] + M1[i][3] * M2[3][j];
  }
  return M;
}

//multiplies matrix with vector
function VMulti(M, V) {
  var Vect = new Array();
  var i = 0;
  for (;i < 4; i++) Vect[i] = M[i][0] * V[0] + M[i][1] * V[1] + M[i][2] * V[2] + M[i][3] * V[3];
  return Vect;
}

function VMulti2(M, V) {
  var Vect = new Array();
  var i = 0;
  for (;i < 3; i++) Vect[i] = M[i][0] * V[0] + M[i][1] * V[1] + M[i][2] * V[2];
  return Vect;
}

// add to matrices
function MAdd(M1, M2) {
  var M = [[],[],[],[]];
  var i = 0;
  var j = 0;
  for (; i < 4; i++) {
    j = 0;
    for (; j < 4; j++) M[i][j] = M1[i][j] + M2[i][j];
  }
  return M;
}

function Translate(M, Dx, Dy, Dz) {
  var T = [
  [1,0,0,Dx],
  [0,1,0,Dy],
  [0,0,1,Dz],
  [0,0,0,1]
  ];
  return MMulti(T, M);
}

function RotateX(M, Phi) {
  var a = Phi;
  a *= Math.PI / 180;
  var Cos = Math.cos(a);
  var Sin = Math.sin(a);
  var R = [
  [1,0,0,0],
  [0,Cos,-Sin,0],
  [0,Sin,Cos,0],
  [0,0,0,1]
  ];
  return MMulti(R, M);
}

function RotateY(M, Phi) {
  var a = Phi;
  a *= Math.PI / 180;
  var Cos = Math.cos(a);
  var Sin = Math.sin(a);
  var R = [
  [Cos,0,Sin,0],
  [0,1,0,0],
  [-Sin,0,Cos,0],
  [0,0,0,1]
  ];
  return MMulti(R, M);
}

function RotateZ(M, Phi) {
  var a = Phi;
  a *= Math.PI / 180;
  var Cos = Math.cos(a);
  var Sin = Math.sin(a);
  var R = [
  [Cos,-Sin,0,0],
  [Sin,Cos,0,0],
  [0,0,1,0],   
  [0,0,0,1]
  ];
  return MMulti(R, M);
}

function DrawQube() {
  // calc current normals
  var CurN = new Array();
  var i = 5;
  Q.LastPx = 0;
  for (; i > -1; i--) CurN[i] = VMulti2(MQube, Q.Normal[i]);
  if (CurN[0][2] < 0) {
    if (!Q.Line[0]) { DrawLine(Q[0], Q[1]); Q.Line[0] = true; };
    if (!Q.Line[1]) { DrawLine(Q[1], Q[2]); Q.Line[1] = true; };
    if (!Q.Line[2]) { DrawLine(Q[2], Q[3]); Q.Line[2] = true; };
    if (!Q.Line[3]) { DrawLine(Q[3], Q[0]); Q.Line[3] = true; };
  }
  if (CurN[1][2] < 0) {
    if (!Q.Line[2]) { DrawLine(Q[3], Q[2]); Q.Line[2] = true; };
    if (!Q.Line[9]) { DrawLine(Q[2], Q[6]); Q.Line[9] = true; };
    if (!Q.Line[6]) { DrawLine(Q[6], Q[7]); Q.Line[6] = true; };
    if (!Q.Line[10]) { DrawLine(Q[7], Q[3]); Q.Line[10] = true; };
  }
  if (CurN[2][2] < 0) {
    if (!Q.Line[4]) { DrawLine(Q[4], Q[5]); Q.Line[4] = true; };
    if (!Q.Line[5]) { DrawLine(Q[5], Q[6]); Q.Line[5] = true; };
    if (!Q.Line[6]) { DrawLine(Q[6], Q[7]); Q.Line[6] = true; };
    if (!Q.Line[7]) { DrawLine(Q[7], Q[4]); Q.Line[7] = true; };
  }
  if (CurN[3][2] < 0) {
    if (!Q.Line[4]) { DrawLine(Q[4], Q[5]); Q.Line[4] = true; };
    if (!Q.Line[8]) { DrawLine(Q[5], Q[1]); Q.Line[8] = true; };
    if (!Q.Line[0]) { DrawLine(Q[1], Q[0]); Q.Line[0] = true; };
    if (!Q.Line[11]) { DrawLine(Q[0], Q[4]); Q.Line[11] = true; };
  }
  if (CurN[4][2] < 0) {
    if (!Q.Line[11]) { DrawLine(Q[4], Q[0]); Q.Line[11] = true; };
    if (!Q.Line[3]) { DrawLine(Q[0], Q[3]); Q.Line[3] = true; };
    if (!Q.Line[10]) { DrawLine(Q[3], Q[7]); Q.Line[10] = true; };
    if (!Q.Line[7]) { DrawLine(Q[7], Q[4]); Q.Line[7] = true; };
  }
  if (CurN[5][2] < 0) {
    if (!Q.Line[8]) { DrawLine(Q[1], Q[5]); Q.Line[8] = true; };
    if (!Q.Line[5]) { DrawLine(Q[5], Q[6]); Q.Line[5] = true; };
    if (!Q.Line[9]) { DrawLine(Q[6], Q[2]); Q.Line[9] = true; };
    if (!Q.Line[1]) { DrawLine(Q[2], Q[1]); Q.Line[1] = true; };
  }
  Q.Line = [false,false,false,false,false,false,false,false,false,false,false,false];
  Q.LastPx = 0;
}

function Loop() {
  if (Testing.LoopCount > Testing.LoopMax) return;
  var TestingStr = String(Testing.LoopCount);
  while (TestingStr.length < 3) TestingStr = "0" + TestingStr;
  MTrans = Translate(I, -Q[8].V[0], -Q[8].V[1], -Q[8].V[2]);
  MTrans = RotateX(MTrans, 1);
  MTrans = RotateY(MTrans, 3);
  MTrans = RotateZ(MTrans, 5);
  MTrans = Translate(MTrans, Q[8].V[0], Q[8].V[1], Q[8].V[2]);
  MQube = MMulti(MTrans, MQube);
  var i = 8;
  for (; i > -1; i--) {
    Q[i].V = VMulti(MTrans, Q[i].V);
  }
  DrawQube();
  Testing.LoopCount++;
  Loop();
}

function Init(CubeSize) {
  // init/reset vars
  Origin.V = [150,150,20,1];
  Testing.LoopCount = 0;
  Testing.LoopMax = 50;
  Testing.TimeMax = 0;
  Testing.TimeAvg = 0;
  Testing.TimeMin = 0;
  Testing.TimeTemp = 0;
  Testing.TimeTotal = 0;
  Testing.Init = false;

  // transformation matrix
  MTrans = [
  [1,0,0,0],
  [0,1,0,0],
  [0,0,1,0],
  [0,0,0,1]
  ];
  
  // position information of qube
  MQube = [
  [1,0,0,0],
  [0,1,0,0],
  [0,0,1,0],
  [0,0,0,1]
  ];
  
  // entity matrix
  I = [
  [1,0,0,0],
  [0,1,0,0],
  [0,0,1,0],
  [0,0,0,1]
  ];
  
  // create qube
  Q[0] = new CreateP(-CubeSize,-CubeSize, CubeSize);
  Q[1] = new CreateP(-CubeSize, CubeSize, CubeSize);
  Q[2] = new CreateP( CubeSize, CubeSize, CubeSize);
  Q[3] = new CreateP( CubeSize,-CubeSize, CubeSize);
  Q[4] = new CreateP(-CubeSize,-CubeSize,-CubeSize);
  Q[5] = new CreateP(-CubeSize, CubeSize,-CubeSize);
  Q[6] = new CreateP( CubeSize, CubeSize,-CubeSize);
  Q[7] = new CreateP( CubeSize,-CubeSize,-CubeSize);
  
  // center of gravity
  Q[8] = new CreateP(0, 0, 0);
  
  // anti-clockwise edge check
  Q.Edge = [[0,1,2],[3,2,6],[7,6,5],[4,5,1],[4,0,3],[1,5,6]];
  
  // calculate squad normals
  Q.Normal = new Array();
  for (var i = 0; i < Q.Edge.length; i++) Q.Normal[i] = CalcNormal(Q[Q.Edge[i][0]].V, Q[Q.Edge[i][1]].V, Q[Q.Edge[i][2]].V);
  
  // line drawn ?
  Q.Line = [false,false,false,false,false,false,false,false,false,false,false,false];
  
  // create line pixels
  Q.NumPx = 9 * 2 * CubeSize;
  for (var i = 0; i < Q.NumPx; i++) CreateP(0,0,0);
  
  MTrans = Translate(MTrans, Origin.V[0], Origin.V[1], Origin.V[2]);
  MQube = MMulti(MTrans, MQube);

  var i = 0;
  for (; i < 9; i++) {
    Q[i].V = VMulti(MTrans, Q[i].V);
  }
  DrawQube();
  Testing.Init = true;
  Loop();
  
  // Perform a simple sum-based verification.
  var sum = 0;
  for (var i = 0; i < Q.length; ++i) {
    var vector = Q[i].V;
    for (var j = 0; j < vector.length; ++j)
      sum += vector[j];
  }
  if (sum != validation[CubeSize])
    throw "Error: bad vector sum for CubeSize = " + CubeSize + "; expected " + validation[CubeSize] + " but got " + sum;
}

for ( var i = 20; i <= 160; i *= 2 ) {
  Init(i);
}

Q = null;
MTrans = null;
MQube = null;
I = null;
Origin = null;
Testing = null;
LoopTime = null;
DisplArea = null;

var __time_after = top.JetStream.goodTime();
__data.sum += Math.max(__time_after - __time_before, 1);
__data.n++;
if (__data.n == 20)
    top.JetStream.reportResult(__data.sum / __data.n);
else
    top.JetStream.accumulate(__data);

undefined:3: ReferenceError: top is not defined
var __data = top.JetStream.getAccumulator() || {sum: 0, n: 0};
             ^
ReferenceError: top is not defined
    at eval (eval at runCode (JetStreamDriver.js:161:14), <anonymous>:3:14)
    at runCode (JetStreamDriver.js:161:9)
    at iterate (JetStreamDriver.js:493:13)
    at Object.start (JetStreamDriver.js:374:9)
    at run.js:11:11

